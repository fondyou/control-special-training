# 第一节：51单片机定时器中断

**本节知识点**

- 51单片机的中断过程
- 51单片机的中断系统结构
- 中断系统的相关寄存器
- 中断响应及初始化的一般步骤

## 一、定时器的相关基本概念
> 众所周知，一块单片机的基本由 **「中央处理器CPU」**、**「随机存储器RAM」**、**「只读存储器ROM」**、**「多种I/O口和中断系统」**、**「定时器/计数器」** 构成，

- **时钟周期T（也称振荡周期）:** 是单片机时序中的最小单位，具体计算的方法就是时钟源（晶振）分之一。

- **机器周期：**在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。单片机完成一个操作的最短时间，51单片机:**1个机器周期=6个状态周期=12个时钟周期**。

- **指令周期:**执行一条指令所需要的时间，一般由若干个机器周期组成。

## 二、定时器工作原理

?> 定时器的本质原理就是：每经过1个机器周期，计数存储器的值就加1。因此当使用定时器时，就必须掌握时钟周期和机器周期的关系。

### 1.定时器/计数器结构

- 定时器/计数器在单片机中的脚管位置，如图

![](http://upload-images.jianshu.io/upload_images/6757403-c3bbb5b5798b8c63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 在P3.4，P3.5脚管上标注着T0,T1；它们分别代表着单片机内部的定时/计数器0,1，也就是英文 Timer 0，Timer 1，从图上看，一块51单片机上有着两个Timer，Timer既有计时的功能，又有计数的功能，通过设置与他们相关的特殊功能寄存器可以选择启用定时功能或者记数功能，关于功能的实现将在第三点讲，现在我们主要研究 Timer是什么 。 
- 下面是Timer的结构框图：

![](http://upload-images.jianshu.io/upload_images/6757403-38815a433c9bc30c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 我们可以看到，Timer是一个十六位的加一计数器，TCON（Timer control）指的是Timer的控制寄存器，TMOD（Timer Mode）则是timer的工作方式寄存器；

- 为什么要去实现 Timer 的中断？
> 提高代码的工作效率，由于 Timer 是单片机中的一个独立的单元，不会去占用 CPU 的运行速度，单独运行，自然提高效率 。

### 2.系统运行流程分析

- 51单片机外接的是12MHZ的晶振(实际上是11.0592MHZ),所以51单片机内部的工作频率(时钟脉冲频率)是12MHZ/12=1MHZ=1000000条指令/秒=1条指令/微秒;也就是说,晶振振荡一次,就会给单片机提供一个时钟脉冲,花费的时间是1微秒,此时,CPU会执行一条指令,经历一个机器周期;即:1个机器周期=1微秒=1条指令;

!> 注:个人PC机上的CPU主频是晶振经过倍频之后的频率,这一点恰好与51单片机的相反,51单片机的主频是晶振经过分频之后的频率;

- 总之:51单片机中的时间概念就是通过计数脉冲的个数来测量出来的;1个脉冲=1微秒=1条指令=1个机器周期;

- 51单片机定时器/计数器的简单结构图:

![](http://upload-images.jianshu.io/upload_images/6757403-443dce297156951b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 三、定时器的相关寄存器

> 对硬件（单片机）的操作，从本质上将就是对寄存器的操作。一个寄存器通常是1字节，即8位。每一位（bit）可以联想成一个开关，打开这个开关就能做一件事，关闭这个开关就能停止做一件事。

### 1.定时器的TMOD和TCON寄存器

- 工作方式寄存器TMOD：用于设置定时器的工作方式；
![](http://upload-images.jianshu.io/upload_images/6757403-096898ceafe59b32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


C/T：计数器/定时器功能选择位。 1为计数器模式， 0 为定时器模式。

- 控制寄存器TCON：用于启动和停止定时器的计数，并控制定时器的状态；
![](http://upload-images.jianshu.io/upload_images/6757403-14ddc310b8e8d646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 四、定时器的两种工作模式和四种工作方式

### 1.计数器工作模式
- 就是对外部事件进行计数。计数脉冲来自相应的外部输入引脚T0（P3.4)或T1(P3.5)。当输入信号发生由1至0的负跳变(下降沿)时，计数器（TH0，TL0或TH1，TL1）的值增1。计数的最高频率一般为振荡频率的1/24。

### 2.定时器工作模式
- 也是通过计数实现的。计数脉冲来自内部时钟脉冲，每个机器周期计数值增1，每个机器周期=12个振荡周期，因此计数频率为振荡频率的1/12。所以定时时间=计数值×机器周期。

- 除了可选择定时器和计数器的这两种工作模式外,每个定时器/计数器都有4种工作方式;
- 在方式0、1和2时,T0和T1的工作方式相同;在方式3时,两个定时器/计数器的工作方式不同;

### 工作方式0:
- 工作方式0——13位定时器 / 计数器,最多可计数2的13次方次,即:8192次,[0,8191];

![](http://upload-images.jianshu.io/upload_images/6757403-7d7d89f05fabdd56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 在某一个初值基础上加1计数，当计数满为全“1”，再来一个计数脉冲，就产生一个“溢出中断信号”，TF=1
> 由于第8位计数器中的高三位没有参与工作，故填装初值是应该“避开”此三位

### 工作方式1:
- 工作方式1——16位定时器/计数器,最多可计数2的16次方 次,即:65536次,[0,65535];

![](http://upload-images.jianshu.io/upload_images/6757403-2db7f41a433bddab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 类同于模式 0 ，由于两个计数器为完整的8位，故将计算好的16位初值可直接填装到THx、TLx中。

### 工作方式2:
- 工作方式2——8位自动重装载定时器/计数器，计算次数最多为2^8,即256，,[0,255];

![](http://upload-images.jianshu.io/upload_images/6757403-8e15708dffea8a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 工作方式3:
- 工作方式3——两个8位定时器/计数器，组合扩展模式（只适用于T0） ，计算次数最多为2^8,即256，,[0,255];

![](http://upload-images.jianshu.io/upload_images/6757403-2374241d83d033ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

将T0和T1重新进行“拆分”，“组合”，将T0变为由TH0、HL0组成的两个独立的8位定时/计数器。

> 预置数的计算公式:预置数=最大值-需要计数的次数;

## 六、定时器/计数器的初始化
注:由于51单片机的定时器/计数器使用的时钟脉冲是外部晶振(12MHZ)经过12分频(12MHZ/12=1MHZ)之后的频率,所以,一个时钟脉冲就是1微秒;所以,8192个脉冲=8192微秒=8.192毫秒; 65536个脉冲=65536微秒=65.536毫秒; 256个脉冲=256微秒=0.256毫秒;

1、设置定时器/计数器的工作模式TMOD(常用的是模式1:TMOD=0x01);
2、装入预置数到THx和TLx中(THx=TLx=MAX(8192/65536/256)-计数次数);
3、如果工作在中断方式,则需要开定时器/计数器的中断TCON中的标志位:TF0/TF1=0/1;
4、启动定时器/计数器:TR0/TR1=1;

## 七、定时器实验程序

- 1.设计要求：实现一个秒表，数码管一每秒钟走一次，达到60自动回到0，继续下一轮走时
	
- 2.实现思路：
	- 1.通过定时/计数器，每秒触发一次数码管加1
	- 2.涉及到的功能模块：定时器，中断，数码管操作
	- 3.定时器装填：
	![](http://upload-images.jianshu.io/upload_images/6757403-6e85b83502b8e915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	
	- 需要计数每秒的话，计数921600时溢出即可，在四种方式定时方式中，最大的计数范围是方式2：65536，将921600分解成20份，每份计数46080时溢出，当溢出20次时灯闪烁，每次定时器溢出都要重新装填
	![](http://upload-images.jianshu.io/upload_images/6757403-f33c257b01b07ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	![](http://upload-images.jianshu.io/upload_images/6757403-691dd47af1f12e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	- ps：当晶振的频率为12MHz是相对好算一点，机器周期为1us，TH.x=(65536-50000)256,TL.x=(65536-50000)%256。

- 3.模块设计
	- 初始化
		- 数码管
		- 定时器（ T0 ，工作方式 1 ，装初值，启动（中断初始化后启动））
		- 中断（打开总中断，打开 T0 中断）
	- while(1)
	- 中断服务函数
		- 溢出复位，重新填装计时值
		- 判断溢出次数（达到20次时，计数清零。未到达20次时溢出次数加一）

- 4.实现代码

```C
/*
 *****************************************************************************************
 *	实 验 名 称:定时器中断的应用
 *  实 验 平 台：清翔电子 QX-MCS51开发板
 *	创 建 作 者：miki
 *  功 能 说 明：使用定时器0的方式1测试定时器定时器1s让数码管自加1来实现秒表
 *  github 地 址：
 *	创 建 日 期：2017-11-15
 *****************************************************************************************
 */
/************************************* 包含头文件 ***************************************/
#include <reg52.h>

/**************************************** 宏定义 *****************************************/
#define uint unsigned int 
#define uchar unsigned char

//typedef unsigned char uchar;
//typedef unsigned int uint;

/*************************************** IO口定义 ****************************************/

sbit LED = P1 ^ 0;
sbit DULA_IO = P2^6;
sbit WELA_IO = P2^7;

/************************************* 全局变量定义 **************************************/
uchar GlobalCount = 0;
uchar GlobalNum	= 0;

uchar code GlobalDisplayTable[] = 
	{0x3f,0x06,0x5b,0x4f,0x66,
	 0x6d,0x7d,0x07,0x7f,0x6f};	/* 段选，选择要显示的数字 */

/*************************************** 函数声明 ****************************************/
void timerInterruptInit(void);
void digitalTubeDisplay(uchar num);
void delayMs(uint xms);

/*
 *****************************************************************************************
 * 函数名称：main
 * 函数功能：主函数，整个程序入口
 * 输入参数：无
 * 输出参数：无
 * 其他说明：无
 ******************************************************************************************
 */
void main(void)
{	
    timerInterruptInit();	//定时器中断初始化
    while(1)
    {
		digitalTubeDisplay(GlobalNum);
    }
}

/*
 *****************************************************************************************
 * 函数名称：timerInterruptInit
 * 函数功能：定时器和中断初始化
 * 输入参数：无
 * 输出参数：无
 * 其他说明：无
 ******************************************************************************************
 */
void timerInterruptInit(void)
{
	TMOD = 0x01; //初始化TMOD,定时器0,方式1
	TH0 = (65536 - 50000) / 256; //装填计数
	TL0 = (65536 - 50000) % 256;
	EA = 1; //开放所有中断
	ET0 = 1; //开放定时器0中断控制位
	TR0 = 1; //定时器0开始计时
}

/*
 *****************************************************************************************
 * 函数名称：digitalTubeDisplay
 * 函数功能：数码管显示函数
 * 输入参数：num：需要显示的数字
 * 输出参数：无
 * 其他说明：无
 ******************************************************************************************
 */
void digitalTubeDisplay(uchar num)
{
    uchar ge,shi;
   	
	ge = num % 10;
	shi = num / 10;

	/*************** 显示个位 ****************/
	DULA_IO = 1;
   	P0 = GlobalDisplayTable[ge];
   	DULA_IO = 0;

   	P0 = 0xff;

   	WELA_IO = 1;
   	P0 = 0x7f;
   	WELA_IO = 0;

	delayMs(5);

	/*************** 显示十位 ****************/
	DULA_IO = 1;
   	P0 = GlobalDisplayTable[shi];
   	DULA_IO = 0;

   	P0 = 0xff;

   	WELA_IO = 1;
   	P0 = 0xbf;
   	WELA_IO = 0;
	delayMs(5);
}

/*
 *****************************************************************************************
 * 函数名称：delayMs
 * 函数功能：实现毫秒级的延时
 * 输入参数：xms：需要延时时间
 * 输出参数：无
 * 其他说明：无
 ******************************************************************************************
 */
void delayMs(uint xms)
{
    uint x,y;
    for (x=xms;x>0;x--)
        for (y=114;y>0;y--);
}

/*
 *****************************************************************************************
 * 函数名称：Timer0InterruptHandler
 * 函数功能：定时器0中断服务函数
 * 输入参数：无
 * 输出参数：无
 * 其他说明：无
 ******************************************************************************************
 */
void Timer0InterruptHandler() interrupt 1
{
   TH0 = (65536 - 50000) / 256; //触发中断时重新装填计时
   TL0 = (65536 - 50000) % 256;

   GlobalCount ++;
   if (GlobalCount >= 20)
   {
       GlobalCount = 0;

	   GlobalNum ++;
	   if (GlobalNum >= 60)
	       GlobalNum = 0;
   }
}

```